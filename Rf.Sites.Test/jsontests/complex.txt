{"title":"So, how expensive is it to let Castle Windsor / Spring.NET make my object?","body":"\u003cp\u003eLately I was getting increasingly curious about the overhead of using a \u003ca href=\"http://martinfowler.com/articles/injection.html\"\u003eDependency Injection\u003c/a\u003e-container to provide me with instances of my objects. With overhead I mean if and how much longer it takes for the DI container to provide me with the desired instance. \u003c/p\u003e \u003cp\u003eIndeed, this is not an overly interesting number. After all, how often do you instantiate an object in your Application\u0027s lifecycle and even if you do it very often, how does it compare to other activities of your Software like doing a Database Query?\u003c/p\u003e \u003cp\u003eEven so, I was curious, so here we go. First I needed a simple example. I came up with the usual BankAccount stuff that depends on a Exchange rate facility in order to work correctly. The following image gives you an overview: \u003c/p\u003e \u003cimg src=\"/files/images/scrshot_bank.png\" width=\"\" height=\"\" alt=\"System overview Bankaccount\" /\u003e \u003cp\u003eI decided for the possibility of constructor-based injection, such that the normal usage of the BankAccount class would be like that:\u003c/p\u003e \u003cpre class=\"sh_csharp\"\u003e\r\nBankAccount b = new BankAccount(new SimpleExchangeRateEngine());\r\nb.Deposit(new MonetaryValue(\"EUR\", 1000.23M));\r\n\u003c/pre\u003e\r\nThe first DI container I used was the \u003ca href=\"http://www.castleproject.org/container/index.html\"\u003eCastle Project Windsor container\u003c/a\u003e, which we have started to use on a customer\u0027s project. Necessary configuration aspects can be covered in the app.config and the configuration for this specific example looks like this:\r\n\u003cpre class=\"sh_csharp\"\u003e\r\n&lt;configuration&gt;\r\n  &lt;configSections&gt;\r\n    &lt;section name=&quot;castle&quot;\r\n      type=&quot;Castle.Windsor.Configuration.AppDomain.CastleSectionHandler, Castle.Windsor&quot; /&gt;\r\n  &lt;/configSections&gt;\r\n  &lt;castle&gt;\r\n    &lt;components&gt;\r\n      &lt;component id=&quot;ExchangeEngine&quot; service=&quot;TheBank.IExchangeRateEngine, TheBank&quot;\r\n        type=&quot;TheBank.SimpleExchangeRateEngine, TheBank&quot;\r\n        lifestyle=&quot;transient&quot;  /&gt;\r\n      &lt;component id=&quot;BankAccount&quot; type=&quot;TheBank.BankAccount, TheBank&quot; lifestyle=&quot;transient&quot; /&gt;\r\n    &lt;/components&gt;\r\n  &lt;/castle&gt;\r\n&lt;/configuration&gt;\r\n\u003c/pre\u003e\r\n\u003cp\u003eAs you can see, the two important classes that we will be using are registered in the configuration. \r\nInteresting in this framework is the fact that you can explicitly state the \"service\" (i.e. the interface) which a class implements. You can then obtain a reference to an underlying implementation simply by passing an interface to the \"Kernel\", the part of the DI container that you need to talk to to get the desired object instance. In terms of the given framework this looks like that:\u003c/p\u003e\r\n\u003cpre class=\"sh_csharp\"\u003e\r\nIWindsorContainer c = new WindsorContainer(new XmlInterpreter());\r\nBankAccount b = c.Resolve\u003cBankAccount\u003e();\r\n\u003c/pre\u003e\r\n\u003cp\u003eHow did the dependency to the \u003cstrong\u003eIExchangeRateEngine\u003c/strong\u003e service go into the BankAccount? This is a feature of the framework. It looks at the BankAccount constructor and will find that for the necessary service to be provided there is an entry in the configuration. It instantiates the dependency and passes it to the BankAccount instance.\u003c/p\u003e\r\n\u003cp\u003eFor testing the construction speed, I wrote a program with two loops: The outer one ten times, the inner ones 10000 times the creation of a BankAccount object in the following ways:\u003c/p\u003e\r\n\u003col\u003e\r\n \u003cli\u003eSimple Instantiation with new as already shown\u003c/li\u003e\r\n \u003cli\u003eInstantiation with the Activator: Activator.CreateInstance(typeof(BankAccount), new SimpleExchangeRateEngine());\u003c/li\u003e\r\n \u003cli\u003eDI based creation with Castle Windsor as already shown\u003c/li\u003e\r\n \u003cli\u003eDI based creation with Spring.NET\u003c/li\u003e\r\n\u003c/ol\u003e\r\n\u003cp\u003eJust for completeness I had a quick look at \u003ca href=\"http://www.springframework.net/\"\u003eSpring.NET\u003c/a\u003e and paced it through pretty much the same routine. The major difference here is that for constructor-based dependency injection you need to explicitly state the constructor argument and what object of the registry should be passed in.\u003c/p\u003e\r\n\u003cpre class=\"sh_csharp\"\u003e\r\n&lt;configuration&gt;\r\n  &lt;configSections&gt;\r\n    &lt;sectionGroup name=&quot;spring&quot;&gt;\r\n      &lt;section name=&quot;context&quot; type=&quot;Spring.Context.Support.ContextHandler, Spring.Core&quot;/&gt;\r\n      &lt;section name=&quot;objects&quot; type=&quot;Spring.Context.Support.DefaultSectionHandler, Spring.Core&quot; /&gt;\r\n    &lt;/sectionGroup&gt;\r\n  &lt;/configSections&gt;\r\n  &lt;spring&gt;\r\n    &lt;context&gt;\r\n      &lt;resource uri=&quot;config://spring/objects&quot;/&gt;\r\n    &lt;/context&gt;\r\n    &lt;objects xmlns=&quot;http://www.springframework.net&quot;&gt;\r\n      &lt;object id=&quot;ExchangeEngine&quot; type=&quot;TheBank.SimpleExchangeRateEngine, TheBank&quot; singleton=&quot;false&quot; /&gt;\r\n      &lt;object id=&quot;BankAccount&quot; type=&quot;TheBank.BankAccount, TheBank&quot; singleton=&quot;false&quot;&gt;\r\n        &lt;constructor-arg name=&quot;engine&quot; ref=&quot;ExchangeEngine&quot;/&gt;\r\n      &lt;/object&gt;\r\n    &lt;/objects&gt;\r\n  &lt;/spring&gt;\r\n&lt;/configuration&gt;\r\n\u003c/pre\u003e\r\n\u003cp\u003eA call to this framework looks like this:\u003c/p\u003e\r\n\u003cpre class=\"sh_csharp\"\u003e\r\nIApplicationContext ctx = ContextRegistry.GetContext();\r\nBankAccount b = (BankAccount)ctx.GetObject(\"BankAccount\");\r\n\u003c/pre\u003e\r\n\u003cp\u003eAnyway, I used the \u003cstrong\u003eStopWatch\u003c/strong\u003e object to time the 10000 instantiation loops and calculated an average. Here are the findings (average min/max values out of the ten times that the whole cycle was repeated, Release build running outside vshost) in milliseconds:\u003c/p\u003e\r\n\u003cul\u003e\r\n \u003cli\u003eNormal construction: 0.0001 / 0.0002\u003c/li\u003e\r\n \u003cli\u003eActivator construction: 0.0069 / 0.0071\u003c/li\u003e\r\n \u003cli\u003eContainer construction (Castle Windsor): 0.1014 / 0.1068\u003c/li\u003e\r\n \u003cli\u003eContainer construction (Spring.NET): 0.069 / 0.0722\u003c/li\u003e\r\n\u003c/ul\u003e\r\n\u003cp\u003eIt should be noted that the very first instantiation is the most costly one in any scenario and that I have taken out the first instantiation in the Container case because that one is significantly slower than anything else: \r\n\u003cul\u003e\r\n \u003cli\u003eContainer construction (Castle Windsor): 55 milliseconds\u003c/li\u003e\r\n \u003cli\u003eContainer construction (Spring.NET): 45 milliseconds\u003c/li\u003e\r\n\u003c/ul\u003e\r\n\u003cp\u003e, a bl... eternity...\u003c/p\u003e\r\n\u003cp\u003eHowever, the Container seems to exist as some kind of singleton, since the recreation of the container did not affect that number (for both containers).\u003c/p\u003e\r\n\u003cp\u003eWell, yeah, one can state dramatically that the creation of an object via DI takes about 1000 times longer than by writing a simple \"new\". But since I am not a very dramatic person, and since us Engineers always have to live with conflicting options, I will not elaborate further.\u003cp\u003e\r\n\u003c/p\u003e\r\n\u003cp\u003e\u003ca href=\"http://www.dotnetkicks.com/kick/?url=http%3a%2f%2frealfiction.net%2f%3fq%3dnode%2f143\"\u003e\u003cimg src=\"http://www.dotnetkicks.com/Services/Images/KickItImageGenerator.ashx?url=http%3a%2f%2frealfiction.net%2f%3fq%3dnode%2f143&amp;bgcolor=0000CC\" border=\"0\" alt=\"kick it on DotNetKicks.com\" /\u003e\u003c/a\u003e\u003c/p\u003e","publishdate":"\/Date(1197215026000)\/","isMarkdown":false,"tags":["programming","dotnet","TrivadisContent","software architecture","castle windsor","dependency injection"]}
